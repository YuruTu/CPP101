C++中的智能指针（Smart Pointers）是为了解决手动内存管理带来的问题，如内存泄漏、野指针等。智能指针通过自动管理内存的生命周期，减少了开发者手动释放内存的负担，同时提高了程序的安全性。C++11标准引入了智能指针，并且它们在标准库中有了很好的实现。

### C++的智能指针类型

在C++中，常见的智能指针有以下三种：

1. **`std::unique_ptr`**
2. **`std::shared_ptr`**
3. **`std::weak_ptr`**

每种智能指针有不同的功能和适用场景。

### 1. `std::unique_ptr`

`std::unique_ptr`是最基础的智能指针，它实现了独占式所有权管理，也就是说，`unique_ptr`指向的资源只能被一个指针所拥有，无法被复制或共享。当`unique_ptr`超出作用域时，它会自动释放所管理的内存。

#### 特点：

* **独占所有权**：一个`unique_ptr`对象只能有一个所有者。
* **不能复制**：`unique_ptr`不能被复制，只能通过移动语义来转移所有权。
* **自动释放内存**：当`unique_ptr`对象超出作用域时，会自动释放内存。



### 2. `std::shared_ptr`

`std::shared_ptr`是一个引用计数智能指针，它允许多个指针共享对同一资源的所有权。当最后一个指向该资源的`shared_ptr`被销毁时，资源会被自动释放。`shared_ptr`通过引用计数来跟踪有多少个`shared_ptr`实例正在共享资源。

#### 特点：

* **共享所有权**：多个`shared_ptr`可以共同管理同一块内存。
* **引用计数**：每个`shared_ptr`都维护一个引用计数，当引用计数为零时，内存会被释放。
* **线程安全**：`shared_ptr`的引用计数是线程安全的，但它指向的资源本身不一定是线程安全的。



### 3. `std::weak_ptr`

`std::weak_ptr`是一个弱引用智能指针，它不改变资源的引用计数。`weak_ptr`通常用于解决`shared_ptr`的循环引用问题。`weak_ptr`不会干涉资源的销毁，它只是观察`shared_ptr`指向的资源。

#### 特点：

* **不增加引用计数**：`weak_ptr`不会改变资源的引用计数。
* **解决循环引用问题**：用于打破`shared_ptr`之间的循环引用。
* **转换为`shared_ptr`**：可以通过`weak_ptr`的`lock()`方法获取一个有效的`shared_ptr`，如果资源已经被释放，`lock()`将返回一个空的`shared_ptr`。

### 代码示例
```




#include <iostream>
#include <memory>


class Demo final {
public:
	Demo() :data(10) {
		std::cout << "Demo Constructor" << std::endl;
	}
	~Demo() {
		std::cout << "Demo Destructor" << std::endl;
	}

	Demo(const Demo&) {
		std::cout << "Demo Copy Constructor" << std::endl;
	}

	Demo(Demo&&) noexcept {
		std::cout << "Demo Move Constructor" << std::endl;
	}

	Demo& operator=(const Demo&) {
		std::cout << "Demo Copy Assignment" << std::endl;
	}

	Demo& operator=(Demo&&) noexcept {
		std::cout << "Demo Move Assignment" << std::endl;
	}


	void show() {
		std::cout << "Demo show method, data" << data << std::endl;
	}

private:
	int data;
};


void demoUniquePtr() {
    std::unique_ptr<Demo> ptr1 = std::make_unique<Demo>();  // ptr1独占内存
	ptr1->show();

   //std::unique_ptr<int> ptr2 = ptr1;  // 错误：不能复制 unique_ptr
   // std::unique_ptr<int> ptr2(ptr1);
    std::unique_ptr<Demo> ptr2 = std::move(ptr1);  // 转移所有权
    // ptr1->show();
    ptr2->show();  // 输出：10
    // ptr1 不再拥有该资源，访问 ptr1 会导致未定义行为
}

void demoSharedPtr() {
    std::shared_ptr<Demo> ptr1 = std::make_shared<Demo>();  // 创建 shared_ptr，引用计数为 1
	ptr1->show();
    {
        std::shared_ptr<Demo> ptr2 = ptr1;  // ptr1 和 ptr2 共享同一块内存，引用计数增加到 2
		ptr2->show();
		std::cout << "Reference Count: " << ptr1.use_count() << std::endl;  // 输出：2

    }  // ptr2 超出作用域，引用计数减少到 1
    std::cout << "Reference Count: " << ptr1.use_count() << std::endl;  // 输出：1

}  // ptr1 超出作用域，引用计数变为 0，内存被释放


void demoWeakPtr() {
    std::shared_ptr<Demo> ptr1 = std::make_shared<Demo>();
    std::weak_ptr<Demo> weakPtr = ptr1;  // weak_ptr 不增加引用计数

    std::cout << "Before lock: " << weakPtr.use_count() << std::endl;  // 输出：1

    // 使用 weak_ptr 转换为 shared_ptr
    std::shared_ptr<Demo> ptr2 = weakPtr.lock();
	ptr2->show();
    std::cout << "Reference Count: " << ptr1.use_count() << std::endl;
    ptr1.reset();  // 释放 ptr1
    std::cout << "Reference Count: " << ptr1.use_count() << std::endl;
    std::shared_ptr<Demo> ptr3 = weakPtr.lock();  // weak_ptr 变为空指针
    if (!ptr3) {
        std::cout << "ptr3 is expired" << std::endl;  // 输出：ptr3 is expired
    }
}

int main () {
   // demoUniquePtr();
   //demoSharedPtr();
   demoWeakPtr();
   return 0;
}

```

### 智能指针的优点

* **自动内存管理**：智能指针通过自动管理内存，避免了内存泄漏的问题。
* **异常安全**：当程序中发生异常时，智能指针的析构函数会被调用，自动释放内存。
* **提高代码可读性与安全性**：使用智能指针可以减少手动调用`delete`和`new`的错误，提高代码的可读性和安全性。

### 总结

* **`std::unique_ptr`**：独占所有权，不能共享或复制。
* **`std::shared_ptr`**：引用计数，多个指针可以共享对同一资源的所有权。
* **`std::weak_ptr`**：弱引用，不增加引用计数，主要用于解决循环引用。

智能指针通过自动化内存管理，避免了手动管理内存时可能出现的错误和资源泄漏，因此是C++中非常重要的一部分。
